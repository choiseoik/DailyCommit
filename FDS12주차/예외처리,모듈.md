# 예외처리

> 요청을 받아서 뿌려주면 끝이나 프론트엔드는 브라우저의 상태라는 것이 있고 상태가 변함에 따라 화면이 변화무쌍하게 변화해야된다.

문법 에러와 같이 프로그래머의 실수로 인해 에러가 발생하는 경우도 있지만, 네트워크 에러와 같이 코드와는 무관한 이유로 발생하는 에러도 있다.

코드 실행중에 에러가 발생하면, 코드의 실행이 중단되어 그 시점에 실행 중이었떤 작업을 완료할수 없다.
JS 는 이로부터 코드의 실행 흐름을 원상복구 할수 있는 기능을 제공하는데 `try..catch..finally` 구문을 사용하면 에러가 나더라도 코드의 흐름을 지속할 수 있다.

```js
try {
  console.log("에러가 나기 직전까지의 코드는 잘 실행됩니다.");
  new Array(-1); // RangeError: Invalid array length
  console.log("에러가 난 이후의 코드는 실행되지 않습니다.");
} catch (e) {
  console.log("코드의 실행 흐름이 catch 블록으로 옮겨집니다.");
  alert(`다음과 같은 에러가 발생했습니다: ${e.name}: ${e.message}`);
}
```

```js
try {
  console.log("에러가 나기 직전까지의 코드는 잘 실행됩니다.");
  new Array(-1); // RangeError: Invalid array length
  console.log("에러가 난 이후의 코드는 실행되지 않습니다.");
} catch (e) {
  if (e.name === "RangeError") {
    alert("배열 생성자에 잘못된 인수가 입력됨");
  } else if (e.name === "ReferenceError") {
    alert("선언되지 않은 변수가 사용됨");
  }
}
```

try 블록은 예외처리~~~~

> finally 안에는 무조건 실행시켜야 하는 것들(로딩인디케이터)

```js
for (let i of [1, 2, 3]) {
  try {
    if (i === 3) {
      break;
    }
  } finally {
    console.log(`현재 i의 값: ${i}`);
  }
}
```

- 에러가 안 났을 때 : try - finally
- 에러가 났을 때 : try - 에러발생 - catch - finally

## 직접 에러 발생시키기

Error 생성자와 throw 구문을 사용해서 프로그래머가 직접 에러를 발생시킬수 있다.

```js
try {
  const even = parseInt(prompt("짝수를 입력하세요"));
  if (even % 2 !== 0) {
    throw new Error("짝수가 아닙니다.");
  }
} catch (e) {
  alert(e.message);
}
```

## 비동기식 코드에서의 예외처리

```js
function add(x, y) {
  new Array(-1);
  return x + y;
}

function add2(x) {
  try {
    return add(x, 2);
  } catch (e) {
    alert("add2 도 잡앗다이놈");
  }
  // `add`를 호출
}

function add2AndPrint(x) {
  try {
    const result = add2(x); // `add2`를 호출
    console.log(result); // `console.log`를 호출
  } catch (e) {
    alert("I caught them");
  }
}
add2AndPrint(3); // `add2AndPrint`를 호출
```

> 비동기 에러는 단순 try catch 문으로 잡을 수 없다

try 블록은 호출 스택이 다 비워진다음에 사용이되면 아무 기능도 못한다.

```js
const buttonEl = document.querySelector("button");

try {
  buttonEl.addEventListener("click", e => {
    try {
      new Array(-1);
      alert("버튼이 눌렸습니다.");
    } catch (e) {
      alert("이벤트 리스너 안에서 에러가 발생했습니다.");
    }
  });
} catch (e) {
  alert("에러가 발생했습니다."); // 출력되지 않음
}
```

## Promise

> 비동기 함수가 진짜 좋은 이유가 try catch 때문이다.

Promeise 객체는 세가지 상태를 가질 수 있다.

- pending - Promise 객체에 결과값이 채워지지 않은 상태
- fulfiled - Promise 객체에 결과값이 채워진 상태
- rejected - Promise 객체에 결과값을 채우려고 시도하다가 에러가 난 상태

```js
const p = new Promise(resolve => {
  const even = parseInt(prompt("짝수를 입력하세요"));
  if (even % 2 !== 0) {
    throw new Error("짝수가 아닙니다.");
  } else {
    resolve(even);
  }
});

p.then(
  even => {
    return "짝수입니다.";
  },
  e => {
    return e.message;
  }
).then(alert);

// 이렇게 도 바꿀수 있다. catch 를 사용해서

p.then(even => {
  return "짝수입니다.";
})
  .catch(e => {
    return e.message;
  })
  .then(alert);
```

> promise 가 복잡한 이유는 비동기 자체가 복잡하고 언어를 바꾸지 않고 기능을 추가하려다 보니깐 너무 어려워짐

> 넘복잡해서 간단하고 깔끔하게 만든게 비동기 프로그래밍

## 비동기 함수

```js
async function func() {
  try {
    const res = await fetch("https://nonexistent-domain.nowhere");
  } catch (e) {
    console.log(e.message);
  }
}

func(); // 출력 결과: Failed to fetch
```

# 모듈

> 한 파일내에 모든것을 짜는 것은 고통스럽다!

구형 브라우저는 모듈을 지원하지 않는다. 그래서 브라우저 내장 모듈은 사용하지않고 webpack, Parcel 등의 모듈 번들러를 사용한다.

? 웹팩과 파셀의 차이점 : rkwkd zms ckdlwja 모듈을 하나로 합칠 때 의존성이 다르다. webpack 는 import 방식으로 자신이 사용되는 js 를 불러오고 parcel 은 html 파일에서 필요성을 파악한다.

> 모듈 번들러 여러 모듈을 하나의 파일로 합쳐줌 + transfiling

## 모듈이란?

모듈은 기본적으로 Javascript 코드를 담고 있는 파일이다.

- 별다를 처리를 해주지 않아도 엄격모드로 동작
- import, export 구문사용
- 모듈의 가장 바깥쪽에서 선언된 이름은 전역스코프가 아니라 모듈 스코프에서 선언된다.

## 모듈 스코프

모듈 내부의 가장 바깥 스코프에서 이름을 선언하더라도, 전역 스코프가 아니라 모듈 스코프에서 선언된다.

> react 는 undefined, null 을 표현해 주지않는다.

## export & import

## default export

모듈을 대표하는 하나의 값을 지정하고 그 `값`을 다른 모듈에서 편하게 불러와서 사용할 수 있다.

모듈에는 하나의 default export 와 여러개의 named export 지정할 수 있다.

```react
// `React`라는 이름의 default export와,
// Component, Fragment라는 일반적인 export를 동시에 가져오기
import React, { Component, Fragment } from 'react';
```

## 모듈 사용시 주의할 점

모듈 번들러는 import 를 하지 않으면 실행시키지 않는다.
