# Modern JavaScript 

## 1.1 호이스팅

```js
function getValue (condition){
  var value;
  if(condition){
    value = "blue";
    return value;
  }
  else{
    return null;
  }
}
```

### 결과

```js
=> undefined
   getValue();
=> null
   getValue(1);
=> 'blue'
```

자바스크립트를 처음 접하는 개발자는 호이스팅 선언에 익숙해지는데 시간이 걸리며, 이 독특한 동작을 잘못 이해하여 버그를 발생시키기도 한다. 이러한 이유로 ECMAScript6에서는 변수 생명 주기를 개발자가 더 잘 제어하도록 하기 위해 블록 레벨 스코프 옵션이 도입되었다.

## 블록 레벨 선언

블록-레벨 선언이란 주어진 블록 스코프 밖에서는 저근할 수 없는 바인딩을 선언 하는 것이다. 렉시컬 스코프로도 불리는 블록 스코프는 다음과 같은 곳에 만들어 진다

* 함수 내부
* 블록 내부({와}를 사용하여 지정)

많은 C기반 언어는 블록 스코프로 동작하며, 자바스크립트에서도 그와 같은 유연성을 제공하려는 의도로 ECMAScript6에 블록 레벨 선언을 도입했다.

### const로 객체 선언하기

const 선언은 바인딩을 변경하지 못하도록 하는 것이지, 바인딩 된 값의 변경을 막는 것은 아니다. 즉, 객체를 const로 선언해도 객체가 가진 값은 수정할 수 있다.

```js
const person = {
  name: "nicholas"
};

person.name = "Greg";

person = {
  name: "Greg"
}; // 에러발생
```

앞의 코드에서는 하나의 프로퍼티를 가진 객체를 초깃값으로 하여 person 바인딩을 만들었다. person.name을 변경하는 것은 person 객체가 가진 값을 변경하는 것이지 person변수에 대한 바인딩을 변경하는 것이 아니기 때문에 에러가 발생하지 않는다. 하지만 이 코드에서 person에 값을 할당하려고 하면 에러가 발생한다. 객체를 const로 선얼할 때 발생하는 이런 독특한 동작은 잘못 이해하기 쉽다. const는 바인딩된 값의 수정을 막는 것이 아니라, 바인디으이 수정을 방지한다는 것을 기억하자.

```js
var RegExp = "hello";
console.log(window.RegExp);
console.log(window.RegExp === RegExp);

var ncz = "Hi";
console.log(window.ncz);
```

let과 const 블록 바인딩은 자바스크립트에 이해하기 쉬운 렉시컬 스코프를 도입한다. 이 선언들은 호이스팅되지 않고 선언된 블록 안에서만 존재한다. 블록 바인딩은 변수가 꼭 필요한 곳에 바로 선언할 수 있기 때문에 다른 언어와 좀 더 유사한 동작을 제공하여 뜻하지 않은 에러를 감소시킬 것이다. 그러나 typeof와 같은 안전한 연산자들도 선언하기 전에 블록 바인딩에 접근하려고 시도하면, 바인딩이 TDZ에 있으므로 에러가 발생한다.

let 과 const는 대부분 var와 유사한 방식으로 동작한다. 그러나 반복문에서는 다르다. for-in, for or문에서, 반속 실행 시마다 let과 const는 각각의 새로운 바인딩을 만든다. 결과적으로 반복문 안에서 만들어진 함수는(var로 선언한 경우처럼) 최종 반복 이후에 바인딩된 값에 접근하는 것이 아니라 현재 반복문 바인딩 값에 접근할 수 있다. let 선언은 for문에서도 마찬가지로 잘 동작하는 반면, const 선언을 사용하면 에러가 발생할 수 있다.

### 스코프 연쇄

함수 내부 코드에서, 매개변수 혹은 그 함수 안에서 정의된 변수만 사용할 수 있는 것은 아니다.

```js
const five = 5;
function add5(x){
  return x + five;
}

add5(3);
```

add5함수의 return 구문에서 함수 바깥에 있는 변수 five의 값을 가져와 사용했다. 이는 심지어 함수가 여러 겹 중첩 되어 있다고 하더라도 가능하다.

```js
const five =5;
function add5(x){
  function add(y){
    return x+y;
  }
  return add(five);
}
add5(3);
```

코드의 실행 흐름이 식별자에 도달하면, 먼저 그 식별자와 같은 이름을 갖는 변수를 현재 스코프에서 찾아보고, 변수가 존재하면 그것을 그대로 사용한다. 만약 현재 스코프에서 변수를 찾지 못하면 바로 바깥쪽 스코프에서 변수를 찾아야 한다. 있으면 사용하고 없으면 바깥쪽 스코프로 올라가서 다시 찾아보는, 이 과정이 반복된다. 이런 과정을 스코프 연쇄라고 한다. 이 과정은 가장 바깥쪽에 있는 스코프를 만날 때까지 반복되며, 끝까지 갔는데도 같은 이름의 변수를 찾지 못하면, 그제서야 에러가 발생한다. 가장 바깥에 있는 스코프를 최상위 스코프 혹은 전역 스코프 라고 부른다. 위코드에서는 five가 전역 스코프이다.
