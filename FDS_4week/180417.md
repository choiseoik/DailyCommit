# 180417 화

## 퀴즈

---

* Object.create 정적 메소드를 사용해서, 새 객체를 생성하며 그에 대한 프로토타입을 지정해줄수 있다. (0)

* 생성자의 prototype 속성에는 빈 객체가 자동 생성된다. (x)

오늘은 벰게임을 만들겠다.

---

## 배열

* 유사 배열 객체

```js
'hello'[0]; // 'h'
'hello'.slice(2, 4); // 'll'
for (let c of 'hello') {
  console.log(c);
}

```

* 다차원 배열 : 간단하게 다루기

```js

const table = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];
```

## 3.1 값 더 알아보기

* 스코프 : 변수의 유효범위.
* 매개변수 : 함수안에서만 유효한 변수.

> 매개변수는 함수 스코프를 갖는다.
>
> 프로토 타입 몰라도 모든 과정진행할 수 있다. 하지만 면접 문제를 준비한다면 해야된다.!!

* let 과 const 더 알아보기
  * let과 const는 같은 이름을 갖는 변수의 재선언을 허용하지 않습니다.
  * 변수가 선언되기 전에 참조하려고 하면 에러가 납니다.
  * ES2015 이전에는 변수를 위와 같이 사용해도 에러가 나지 않았습니다.(var)
  * let과 const가 바로 블록 스코프(block scope)를 갖는다

* var 변수 (면접용)
  * var는 let과 유사하게, 값을 다시 대입할 수 있는 변수
  * var는 함수의 매개변수와 유사하게, 함수 스코프를 갖는다.
  * var 변수는 함수 스코프를 가진다. 블록스코프가 아니라 (for문, if문 다 뚫고 나감)
  * var를 통한 변수 선언은 재선언을 허용.
  * 호이스팅 => 선언부만 끌어올려짐 ex) var x =1 잇으면 var x만;;)
  * 예전에 js잘한다 => 호이스팅잘한다. 함수 스코프 잘한다. 로 통햇음.

```js
  console.log(foo); // undefined
var foo = 1;

function func() {
  console.log(bar); // undefined
  var bar = 1;
}
func();
```

var의 문제점 !!

```js
for (var i = 0; i < 3; i++) {
  console.log('outer');
  // 위아래 두 `i` 변수는 같은 함수 스코프에서 정의된 같은 변수입니다.
  // 바깥쪽 루프를 한 번 도는 동안, 안쪽 루프를 도느라 이미 `i`의 값이 3이 되어버렸습니다.
  for (var i = 0; i < 3; i++) {
    console.log('inner');
  }
}
```

* 전역 변수 (Global Variable)
* 전역 스코프는 스코프 체인의 가장 바깥쪽에 있는 스코프입니다.(Global Scope)
* 다행히 호이스팅은 나지 않는다.

### 에러가 안남 (;;) 이상한놈들

```js
function func() {
  variable = 1; // `variable`이라는 변수가 선언된 적 없으므로, 전역 변수가 됩니다.
}

func();
console.log(variable); // 1
```

전역 변수는 코드의 어떤 부분에서든 아무런 제한 없이 접근하고 조작할 수 있습니다. 이런 특징이 편하고 좋아보이지만, 음... 강남역 한복판에 누구나 아무런 제한없이 쓸 수 있는 사물함을 둔다고 생각해보세요.

어떤 프로그래밍 언어를 사용하건, 전역 변수에 의존해서 프로그래밍을 하는 것은 굉장히 금기시되는 일입니다. 전역 변수를 남용하다 보면 필시 다음과 같은 어려움을 겪게 됩니다.

* 전역 변수에는 아무런 제한 없이 접근할 수 있으므로, 프로그램의 크기가 커짐에 따라 변수의 값이 어디서 어떻게 변경될지 예측하기 힙듭니다.
* 전역 변수를 통해 프로그램의 너무 많은 부분이 결합(coupling)됩니다. 예를 들어, A.js 파일을 고쳤는데 아무런 상관도 없어 보이던 B.js 파일의 코드가 오동작하게 될 수도 있습니다.
* 코드가 전혀 다른 곳에 위치한 부분에 의존하게 되므로, 전역 변수를 사용한 코드는 이해하기 어렵습니다.

이처럼 전역 변수를 잘못 사용하면 코드를 읽고, 쓰고, 변경하기 어려워집니다.

변수를 선언할 때는 그 변수를 필요로 하는 작은 스코프 안에서만 접근할 수 있도록 하세요. 불가피하게 코드의 여러 부분에서 특정한 값을 공유하고 그 값을 변경해야 할 일이 생긴다면, 전역 변수 대신에 다른 기법5을 활용하세요. 그리고 공유되는 값에 접근할 수 있는 코드의 범위를 최소한으로 줄이고, 그 값은 약속된 방식으로만 변경을 할 수 있도록 제약을 두시기 바랍니다.

---

## 전역객체

* 전역객체는 어느 언어든 있다.

구동 환경| 전역 객체 이름
|----|---|
웹 브라우저|window
웹 워커| self
Node.js| global

* alert 도 전역객체!

---

### 참조 (Reference)

`JavaScript에는 모두 일곱 가지의 타입이 존재합니다.`

1. Boolean
2. Null6
3. Undefined
4. Number
5. String
6. Symbol
7. Object : 참조타입

이 중에 Object 타입, 그러니까 객체를 제외하고는 모두 `원시 타입(primitive type)`으로 불립니다. 객체는 `참조 타입(reference type)`으로 불립니다. 이렇게 분류를 하는 이유는, 둘 사이에 몇 가지 유의할 만한 차이점이 있기 때문입니다.

여기에서 `참조(reference)란, 객체가 컴퓨터 메모리 상에서 어디에 저장되었는 지를 가리키는 값입니다.` JavaScript에서는 우리가 참조를 직접 읽거나 조작할 수 없습니다. 하지만, 언어를 제대로 이해하기 위해서 참조가 무엇인지 알아야 할 필요는 있습니다.

우리가 객체라고 생각하고 다루어왔던 값은 실제로는 객체에 대한 참조입니다.

참조가 무엇인지는 브라우저 마다 다르다.(메모리상의 위치를 나타내는 값)

> 값이 매개변수에 값을 대입해도, 원래 변수에는 아무런 영향도 미치지 못한다.
>
> JS는 call by value를 못한다! 한다는건 다 거짓말! **vs**
> 변수를 출력할수 있는 방식 call by rapperence
>
> 객체의 참조를 비교하는 것과 내용을 비교하는 것과는 다르다.

### 함수 호출

앞에서, 함수 호출 시에는 인수가 복사되어 매개변수에 대입된다고 설명했습니다. 만약 함수 호출 시에 객체를 인수로 넘긴다면, 이 때 역시 실제로 복사되는 것은 객체 자체가 아니라 참조입니다. 그래서, 우리는 이 참조를 이용해 원본 객체의 내용을 변경할 수 있습니다. 원본이나, 복사된 참조나 같은 객체를 가리키기 때문입니다.

```js
const obj = {};

function addProp(o) {
  o.prop = 1;
}

// 변수 `obj`에 저장되어 있는 참조가 매개변수 `o`에 복사됩니다.
addProp(obj);

console.log(obj.prop); // 1
```

### 객체의 같음 (Equality)

```js
// 계정 관리 시스템에서는, 사용자의 '아이디'가 같다면 같은 사용자라고 볼 수 있습니다.
function User(id) {
  this.id = id;
}

User.prototype.isEqual = function(other) {
  return this.id === other.id;
}

const john1 = new User('john');
const john2 = new User('john');

john1 === john2; // false
john1.isEqual(john2); // true
```

### 불변성 (Immutability)

이제 원시 타입의 특징에 대해서도 살펴보겠습니다.

원시 타입의 값 자체의 내용을 변경할 수 있는 방법은 없습니다. 이런 성질을 불변성(immutability)이라고 하고, "JavaScript의 원시 값은 불변(immutable)이다"라고 말합니다.

예를 들면, 문자열을 변형하는 메소드는 모두 기존 문자열의 내용을 바꾸는 것이 아니라 새 문자열을 반환합니다. 다른 원시 타입의 메소드들도 마찬가지입니다.

```js
const str = 'JavaScript string is immutable!';

str.replace('!', '?'); // 'JavaScript string is immutable?'
str.slice(0, 10); // 'JavaScript'
str.toUpperCase(); // 'JAVASCRIPT STRING IS IMMUTABLE!'

console.log(str); // JavaScript string is immutable!
```

변수에 저장된 원시 타입의 값을 바꾸려면, 오직 변수에 다른 값을 대입하는 방법밖에 없습니다.

원시 타입을 인수로 해서 함수를 호출할 때에는, 원본이 변경될지도 모른다는 걱정을 할 필요가 없습니다. 값이 불변일 뿐더러, 애초에 함수 호출 시에는 값이 복사되어서 전달되기 때문에 원본을 변경할 수 있는 방법이 아예 없습니다.

```js
let str = 'JavaScript string is immutable!';

function func(s) {
  // 여기서 무슨 짓을 해도, `str`에 새 값을 대입하지 않는 한 원본을 변경할 수 있는 방법은 없습니다.
}

func(str);
```

객체의 경우를 생각해보면, 객체 자체의 내용을 변경할 수 있는 방법이 얼마든지 많이 있습니다. 따라서 객체는 가변(mutable)입니다.

가변인 값은 어디서 어떻게 변경될지 알 수 없습니다. 변경되지 말아야 할 객체가 있다면, 정말로 변경되지 않도록 신경 써서 코드를 작성해야 합니다. 그러나 객체가 정말로 변경되지 않았는지를 확인하는 일은 쉽지 않아서, 때때로 객체의 가변성 때문에 프로그래밍이 어려워지기도 합니다.

객체의 가변성 때문에 어려움을 겪고 있다면, 두 가지 해결책을 시도해볼 수 있습니다.

먼저 Object.freeze의 사용을 고려해볼 수 있습니다. Object.freeze는 객체를 얼려서 속성의 추가/변경/삭제를 막습니다.

```js
const obj = {prop: 1};

Object.freeze(obj);

// 모두 무시됩니다.
obj.prop = 2;
obj.newProp = 3;
delete obj.prop;

console.log(obj); // { prop: 1 }
```

> 객체는 가변 vs 원시타입은 불변

다만 Object.freeze를 호출한다고 해서 객체 안에 있는 객체까지 얼려버리지는 않으므로, 중첩된 객체에는 Object.freeze를 사용하기가 조금 까다롭습니다. 그리고, 다음에 소개할 방법과 비교하면 여러모로 편의성이 떨어집니다.

다음으로 [Immutable.js](https://facebook.github.io/immutable-js/) 같은 라이브러리의 사용을 고려해보세요. 이런 라이브러리들은 Object.freeze처럼 객체를 정말로 얼려버리지는 않지만, 객체를 마치 불변인 것처럼 다룰 수 있는 방법을 제공합니다. 다시 말하면, 이 객체들은 (문자열의 예에서 봤던 것처럼) 메소드를 통해 내용이 조금이라도 변경되면 아예 새로운 객체를 반환합니다. 즉, 내용이 달라지면 참조 역시 달라지게 되어 객체의 내용이 변경되었는지를 확인하는 작업이 아주 쉬워집니다. 아래는 Immutable.js에서 제공하는 List를 활용한 예제입니다.

```js
import {List} from 'immutable';

// Immutable.js에서 제공하는 `List`는 배열과 유사하지만, 불변인 것처럼 다룰 수 있는 자료구조입니다.
const list = List.of(1, 2, 3);
const newList = list.push(4); // 새 List 인스턴스를 반환합니다.

// 내용이 달라지면, 참조도 달라집니다.
list === newList; // false
```

특히 React 생태계에서는 Immutable.js가 널리 사용되니, React를 공부하려고 준비중이시라면 불변성 및 관련 라이브러리에 대해 관심을 갖고 살펴볼 필요가 있습니다.

마지막으로, const와 불변성을 잘 구분하시길 바랍니다. const는 '한 번 초기화된 변수에 다른 값을 대입할 수 없다'는 제약을 걸어주는 것이고, 불변성은 '값 자체가 변하지 않는다'는 것입니다. 예를 들어서 const로 선언된 변수에 객체를 대입하면, 이 변수에 새로운 값을 대입할 수는 없지만 이 객체의 내용은 얼마든지 변경할 수 있습니다. 즉, 재대입이 불가능할지라도 가변일 수 있습니다.

## 래퍼 객체 (Wrapper Object)

앞에서 래퍼 객체에 대해 몇 번 언급한 적이 있습니다. 원시 타입의 값은 객체가 아님에도 불구하고, 원시 타입에 점 표기법을 써서 메소드를 호출하거나 속성을 읽어올 수 있는데, 이는 JavaScript가 래퍼 객체(wrapper object)라는 기능을 제공하기 때문입니다.

원시 타입의 값에 대해 속성을 읽으려고 시도하면, 그 값은 그 `순간에만 객체로 변환`되어 **마치 객체인 것처럼 동작합니다.**

```js
const s = 'hello';
s.toUpperCase(); // 'HELLO'
s.length; // 5

const n = 1.2345;
n.toFixed(2); // '1.23'

const b = true;
b.toString(); // 'true'
```

아래는 래퍼 객체를 생성시키기 위해 사용되는 생성자들의 목록입니다.

* String
* Number
* Boolean
* Symbol

위 생성자들을 이용해 우리가 직접 객체를 생성할 수도 있습니다. 하지만 직접 객체를 생성해주지 않아도 원시 타입의 값에 대해 메소드를 호출하거나 속성을 읽을 수 있기 때문에, 직접 객체를 생성해줄 일은 잘 없습니다.

---
node.js 설치중
필요한 버전을 바꿔낄수 있는 버젼 매니저 nvm

### Node 설치

* 버전 매니저 설치
  * Windows - nvm-windows
  * macOS - nvm (설치 후 터미널 재시작)
* 아래 명령을 차례대로 실행
  * nvm install 8.11.1
  * nvm use 8.11.1

지금 당장 필요하지는 않으나 나중에 필요해질 수 있으므로 아래 도구들을 미리 설치하는 것이 좋습니다.

* Windows - windows-build-tools
* macOS - 터미널에서 xcode-select --install 실행

#### 프로젝트 명령

* 프로젝트 의존성 설치
  * npm install
* 프로젝트 실행
  * npm start
* 프로젝트 빌드
  * npm run build

## 2. TIL

호이스팅 궁금하다

근래에 했던 내용들 중에는 가장 이해도가 높은 것 같다. var에 대한 특이한 특징들 면접에 대비한 질문들 같았다. 참조 개념이 조금 어려웠는데 여지껏 우리가 객체에 대한 개념을 바꾸어 주었다. 참조는 객체가 컴퓨터 메모리 상에서 어디에 저장되어있는지를 가리키는 값이다. 우리가 인수를 복사하여 매개변수에 대입한다고 하지만 사실 객체 자체가 아니라 객체의 참조였다. 객체된 참조는 원본객체와 같은 메모리 주소를 가리키기 때문이다. 우리는 객체의 자체를 다루지 않고 객체 참조를 다루는 개념이었다. 그리고 내가 개념이 잘잡혀잇었던 가변성, 불변성 많이 어렵지 않았다. 중간에 freeze와 immutable쪽이 사용해보지 않아서 낯설었지만 어떤 개념을 가지고 있는지는 파악을 하였다. 래퍼객체는 불가변성의 유도리 라고 생각한다.

## 3. repo

[snake game](https://github.com/fds9/fds-snake-game)

[객체의 내용을 통해 비교하고 싶다면, 깊은 비교 기능을 지원하는 라이브러리](https://www.npmjs.com/package/fast-deep-equal)

[요즘핫한 객체를 마치 불변인 것처럼 사용하는 seamless-immutable](https://github.com/rtfeldman/seamless-immutable)

[서버 배포 사이트 netlify](https://www.netlify.com/)