# Javascript 3일차!

## 아침 퀴즈
1. 표현식 (NaN === NaN) 의 결과값은 true 이다. //false
2. 표현식 (3 || 4) 의 결과값은 3 이다. * // true
3. 표현식 (!!{}) 의 결과값은 false 이다. // false
=> 이중 부정을 통해서 빈객체가 false가된다.
4. const obj = {a: 1, b: 2}, c = 'a'; 라 할 때, 표현식 (obj.c) 의 결과값은 1 이다. // 아니오 undefined

    => 대괄호 표기법은 대괄호 안에있는 표현식의 결과값과 같은 이름을 같는 속성의 값을 반환
```js
예시
const obj ={
  '1': 'hello'
}
obj[1]
```



## 아침 Activity
### Mac OS X에서 git의 한글 호환 오류 문제 해결하기
=>http://resoneit.blogspot.kr/2013/06/git.html

---

# 함수 2.6

- 프로그래밍에서의 함수란, 큰 프로그램을 잘게 쪼개어 특정 코드 뭉치를 반복해서 사용할 수 있도록 묶어놓은 코드 뭉치의 단위를 말합니다. 함수를 어떻게 작성하느냐에 따라서 코드의 유지보수성과 가독성이 크게 달라집니다. 또 JavaScript의 함수는 굉장히 많은 기능을 갖고 있는데, 사실 함수의 성질을 모두 이해하면 프로그래밍 언어로서의 JavaScript를 전부 이해한거나 마찬가지라고 할 수 있을 정도입니다. 본 챕터에서는 함수의 기본적인 성질만을 다루고, 이어지는 챕터들에서 나머지 내용을 차근차근 다룰 것입니다.
## 함수의 구성 요소
```js
function add(x, y) {
  const result = x + y;
  return result;
}
```
- ### 위에서 add라는 이름을 갖는 함수를 정의했습니다. 괄호 안의 x와 y를 x, y를 매개변수(parameter)라 하며, return 뒤에 오는 값을 반환값(return value)이라고 합니다.함수를 정의했다면, 아래와 같이 함수 이름 뒤에 괄호를 붙여서 이 함수를 실행시킬 수 있습니다. 이를 함수의 호출(function call)이라고 합니다.
- 여기서 괄호 안에 넘겨준 2, 3을 인수(argument)라고 부릅니다.

## 실행 순서
JavaScript는 기본적으로는 쓰여진 순서대로 실행되지만, 여러 가지 예외가 존재해서 코드의 실행 순서가 이리저리 옮겨다니기도 합니다. 함수 호출도 그 중 하나로, 함수 호출 코드를 만나면 코드의 실행 흐름이 호출된 함수의 내부로 옮겨갑니다. 함수가 값을 반환하면 다시 이전 위치부터 코드의 실행이 재개됩니다.

```js
// 1 - 함수 정의
function add(x, y) {
  return x + y; // 3 - 함수 실행
}
// 2 - 함수 호출
const result = add(2, 3);
// 4 - 나머지 코드 실행
console.log(result);
```
* 여기서 유의할 점은, 함수를 정의하는 것만으로는 함수 내부에 있는 코드가 실행되지 않는다는 것입니다. 함수 내부의 코드를 실행하려면, 반드시 함수를 호출해주어야 합니다.

* ## 매개변수와 인수
위 코드의 x와 y를 가지고 매개변수라고 합니다. 매개변수는 변수의 일종으로, 함수 호출 시마다 인수가 매개변수에 대입됩니다. 위의 코드에서 add(2, 3)과 같이 호출하면 매개변수 x에는 2가, y에는 3이 대입된 채로 나머지 코드가 실행됩니다.

여기서 주의할 점은 매개변수는 바깥에서 선언된 변수와는 관계없는 독립적인 변수라는 것입니다. 예를 들어, 함수 호출 시 인수가 들어갈 자리에 변수를 써주고, 함수 내부에서 매개변수에 새로운 값을 대입한다고 하더라도 인수로 써준 변수의 값이 변경되지 않습니다.
```js
function reassign(x) {
  x = 2;
  return x;
}

const y = 1;
const result = reassign(y); //(y+1)이라도 값이 계산되고 넘어감!

console.log(y); // 1
console.log(result); // 2
```
## 함수로 호출 될때 인수의 변수가 넘어가는 것이 아니라 값이 넘어가는것!(짚고 넘어가심)

* ## 반환값
return 구문은 함수의 반환값을 결정합니다. return 키워드 바로 다음에 오는 값이 함수 호출의 결과값으로 반환되며, 반환되는 즉시 함수 실행이 끝납니다.
```js
function add(x, y) {
  return x + y;
  console.log('이 부분은 실행되지 않습니다.');
}
add(1, 2); // 3
// 3 외에 따로 출력되는 내용이 없습니다.
```
막간을 이용한 repl설명
초록색 출력은 레플의 편의 기능
흰색 출력은 명시적인 출력

## 스코프 (Scope)
함수의 매개변수를 비롯한, 모든 변수들은 특별한 성질을 갖습니다.
```js
function add(x, y) { // 변수 `x`와 `y`가 정의됨
  return x + y;
}
add(2, 3);
console.log(x); // 에러!
```
```js
let i; // 애를 선언 안해주면 10이 출력이 안됨
for(i=0; i<10;i++){
  console.log(i);
}
console.log(i);
```
이렇게, 매개변수와 같이 함수 안에서 정의된 변수는 함수 바깥에서는 접근할 수 없기 때문에 함수 안에서만 사용할 수 있습니다. 즉, 변수는 코드의 일정 범위 안에서만 유효하다는 성질이 있는 것입니다. 이렇게, 특정 변수가 유효한 코드 상의 유효 범위를 가지고 스코프(scope)라고 합니다.

위 예제에서의 x와 y는 함수 add의 내부 코드 안에서만 접근할 수 있습니다. 즉, 매개변수는 함수 스코프를 갖습니다.

스코프의 성질이 미묘해서, 이를 잘 이해하지 못하면 코드를 작성하거나 읽기 어려울 수 있습니다. 아래에서 스코프의 몇 가지 성질들을 살펴보겠습니다.

### 스코프 연쇄 (Scope Chain)
함수 내부 코드에서, 매개변수 혹은 그 함수 안에서 정의된 변수만 사용할 수 있는 것은 아닙니다.
```js
function add(x, y) { // 변수 `x`와 `y`가 정의됨
  return x + y;
}
add(2, 3);
console.log(x); // 에러!
```
이렇게, 매개변수와 같이 함수 안에서 정의된 변수는 함수 바깥에서는 접근할 수 없기 때문에 함수 안에서만 사용할 수 있습니다. 즉, 변수는 코드의 일정 범위 안에서만 유효하다는 성질이 있는 것입니다. 이렇게, 특정 변수가 유효한 코드 상의 유효 범위를 가지고 스코프(scope)라고 합니다.

위 예제에서의 x와 y는 함수 add의 내부 코드 안에서만 접근할 수 있습니다. 즉, 매개변수는 함수 스코프를 갖습니다.

스코프의 성질이 미묘해서, 이를 잘 이해하지 못하면 코드를 작성하거나 읽기 어려울 수 있습니다. 아래에서 스코프의 몇 가지 성질들을 살펴보겠습니다.

* ## 스코프 연쇄 (Scope Chain)
함수 내부 코드에서, 매개변수 혹은 그 함수 안에서 정의된 변수만 사용할 수 있는 것은 아닙니다
```js
const five = 5;
function add5(x) {
  return x + five; // 바깥 스코프의 `five` 변수에 접근
}
add5(3); // 8
```
add5 함수의 return 구문에서 함수 바깥에 있는 변수 five의 값을 가져와 사용했습니다. 이는 심지어 함수가 여러 겹 중첩(nested)되어 있다고 하더라도 가능합니다.
```js
const five = 5;
function add5(x) {
  function add(y) {
    return x + y;
  }
  return add(five);
}
add5(3); // 8
```
코드의 실행 흐름이 식별자에 도달하면, 먼저 그 식별자와 같은 이름을 갖는 변수를 현재 스코프에서 찾아보고, 변수가 존재하면 그것을 그대로 사용합니다. 만약 현재 스코프에서 변수를 찾지 못하면 바로 바깥쪽 스코프에서 변수를 찾아봅니다. 있으면 사용하고 없으면 바깥쪽 스코프로 올라가서 다시 찾아보는, 이 과정이 되풀이됩니다. 이런 과정을 스코프 연쇄(scope chain)라 하고, 이 과정은 가장 바깥쪽에 있는 스코프를 만날 때까지 반복됩니다. 가장 바깥쪽 스코프까지 찾아봤는데도 같은 이름의 변수를 찾지 못하면, 그제서야 에러가 발생됩니다.

가장 바깥에 있는 스코프를 최상위 스코프(top-level scope) 혹은 전역 스코프(global scope)라고 부릅니다. 위 코드에서 five가 정의된 스코프가 바로 전역 스코프입니다.
 * ## 변수 가리기 (Variable Shadowing)
단일 스코프에서는 같은 이름을 갖는 서로 다른 변수가 존재할 수 없습니다. 하지만 스코프 연쇄가 일어나면 이야기가 달라집니다. 아래의 코드에서는 x라는 이름을 갖는 변수가 세 번 정의되었습니다.
```js
const x = 3;

function add5(x) { // `x`라는 변수가 다시 정의됨
  function add(x, y) { // `x`라는 변수가 다시 정의됨
    return x + y;
  }
  return add(x, 5);
}

add5(x);
```
위와 같이, 바깥쪽 스코프에 존재하는 변수와 같은 이름을 같는 변수를 안쪽 스코프에서 재정의할 수 있습니다. 그렇게 되면 안쪽 스코프에서는 바깥쪽 스코프에 있는 이름이 무시됩니다. 이런 현상을 변수 가리기(variable shadowing)라고 합니다.

`질문 지역변수 전역변수 개념이랑 같으냐?
=> 비슷하긴하나 이제 더이상 지역 변수 용어를 안쓰고 여러가지 개념이 추가되었다.`

* ## 어휘적 스코핑 (Lexical Scoping)
스코프는 코드가 작성된 구조에 의해서 결정되는 것이지, 함수 호출의 형태에 의해 결정되는 것이 아닙니다. 예를 들어 봅시다.

```js
function add5(x) {
  const five = 5;
  return add(x);
}

add5(3); // 8

function add(x) {
  return five + x; // ReferenceError: five is not defined
}
```
add라는 함수가 add5라는 함수 안에서 호출되었다고 해서, add 함수 내부에서 add5 함수의 스코프 안에 있는 변수에 접근할 수 있는 것은 아닙니다. 스코프는 코드가 작성된 구조에 의해 결정되는 성질입니다. 위 코드를 동작시키려면, 아래와 같이 작성해야 합니다.
```js
function add5(x) {
  const five = 5;
  function add(x) {
    return five + x;
  }
  return add(x);
}
```
스코프의 종류
이 챕터에서는 매개변수에 대한 함수 스코프를 중점적으로 다루었는데, 사실 스코프의 종류가 더 있습니다. 특히, let과 const로 선언된 변수는 함수 스코프가 아니라 조금 다른 종류의 스코프를 가집니다. 이에 대해서는 값 더 알아보기에서 자세히 다룹니다.
- 값으로서의 함수
다른 값과 마찬가지로, 함수를 선언한 뒤 변수에 대입해서 호출할 수도 있고, 혹은 배열이나 객체에 넣을 수도 있고, 심지어는 함수를 다른 함수에 인수로 넘기거나, 함수에서 함수를 반환할 수도 있습니다.

컴퓨터 과학 분야에서 사용되는 용어 중에 1급 시민(First-Class Citizen)이라는 특이한 용어가 있습니다. 값으로 사용할 수 있는 JavaScript의 함수는 1급 시민입니다. 1급 시민인 함수를 줄여서 1급 함수라 부르기도 합니다.

JavaScript에서는 1급 함수의 성질을 여러 가지 흥미로운 방식으로 활용을 할 수 있습니다. 이에 대한 자세한 내용은 함수형 프로그래밍에서 다룹니다.
- ## 익명 함수 (Anonymous Function)
JavaScript에서 함수를 선언할 때 꼭 이름을 붙여주어야 하는 것은 아닙니다. 아래와 같이 이름을 붙이지 않은 함수를 가지고 익명 함수(anonymous function), 혹은 함수 리터럴(function literal)이라고 합니다.


```js
// 두 수를 더해서 반환하는 익명 함수
function(x, y) {
  return x + y;
}
// 위의 익명 함수는 이름이 없어서 이름을 가지고 호출을 할 수 없습니다.

// 호출을 하려면 변수에 저장한 후에 변수의 이름을 통해 호출해야 합니다.
const add = function(x, y) {
  return x + y;
}
add(1, 2); // 3
```
익명 함수는 함수를 만든 쪽이 아니라 다른 쪽에서 그 함수를 호출할 때 많이 사용됩니다. 대표적인 경우는 함수를 인수로 넘겨줄 때입니다. 예를 들어, 배열의 filter 메소드에 필터링할 조건을 표현하는 함수를 넘겨주면, filter 메소드쪽에서 배열 각 요소에 대해 함수를 호출한 뒤, true를 반환한 요소만을 필터링해서 반환합니다.

화살표 함수 (Arrow Function)
```js
// 여기에서 x + y 는 **바로 반환됩니다.**
const add = (x, y) => x + y;
```
```js
// 바로 반환시키지 않고 function 키워드를 통한 함수 정의처럼 여러 구문을 사용하려면 curly braces({...}) 로 둘러싸주어야 합니다.
// `=>` 다음 부분을 중괄호로 둘러싸면, 명시적으로 `return` 하지 않는 한 아무것도 반환되지 않습니다.
const add = (x, y) => {
  const result = x + y;
  return result;
}
```
```js
// 매개변수가 하나밖에 없다면, 매개변수 부분의 괄호를 쓰지 않아도 무방합니다.
const negate = x => !x;
```
- ## 화살표 함수 (Arrow Function)
```js
// 여기에서 x + y 는 **바로 반환됩니다.**
const add = (x, y) => x + y;
```
화살표 함수는 표기법이 간단하기 때문에 익명 함수를 다른 함수의 인수로 넘길 때 주로 사용됩니다.

```js
[1, 2, 3, 4, 5].filter(x => x % 2 === 0);
```
# 제어 구문
이제까지 나온 코드 예제들은 아주 단순한 계산과 입출력을 하는 프로그램이었습니다. 하지만 실제로 사용되는 프로그램들은 복잡한 논리 구조를 갖고 있고, 그를 통해 프로그램의 여러 기능이 제대로 동작하는 것입니다. 이 챕터에서는 프로그램의 논리 구조를 표현할 수 있는 조건문과 반복문, 그리고 그 밖에 프로그램의 논리 구조에 영향을 미치는 구문들을 살펴볼 것입니다.

## 조건문 (Conditional Statement)
우리가 실제로 사용하는 프로그램들은 수많은 '경우의 수'을 다루고 있습니다.

사용자가 스프레드시트의 셀을 클릭했을 때, 만약 그것이 왼쪽 클릭이면 해당 셀을 선택하고, 왼쪽 더블이면 해당 셀을 편집 모드로 전환하고, 오른쪽 클릭이면 메뉴를 보여준다.
사용자가 더블 클릭한 물약이 만약 빨강 물약이면 HP를 채우고, 파랑 물약이면 MP를 채운다.
사용자가 전송 버튼을 클릭했을 때, 만약 입력 필드가 모두 채워져 있지 않으면 에러 메시지를 보여주고, 입력 필드가 모두 채워져 있으면 서버로 입력 필드의 내용을 전송한다.
이렇게 경우에 따라 프로그램의 동작이 달라야 할 때, 우리는 조건문(conditional statement)을 통해 프로그램의 논리 구조를 표현할 수 있습니다.
## 1. if...else 구문
```js
function roll() {
  return Math.ceil(Math.random() * 6);
}

function game() {
  const result = roll();

  alert(`결과: ${result}`);

  // if...else 구문
  if (result >= 4) {
    // 괄호 안의 조건을 만족하면, 즉 결과값이 true 이면
    // 이 영역의 코드가 실행된다.
    alert('당신이 이겼습니다!');
  } else {
    // 위 조건을 만족하지 않으면, 즉 결과값이 false 이면
    // 대신 이 영역의 코드가 실행된다.
    alert('당신이 졌습니다.');
  }
}

game();
```
## 2. switch 구문
같이 하나의 변수에 대해 많은 경우의 수가 있는 경우, switch 구문을 사용하면 코드를 조금 더 보기 좋게 만들 수 있습니다.

```js
function translateColor(english) {
  let result;
  switch (english) {
    case 'red':
      result = '빨강색';
      break;
    case 'blue':
      result = '파랑색';
      break;
    case 'purple':
      result = '보라색';
      break;
    case 'violet':
      result = '보라색';
      break;
    default:
      result = '일치하는 색깔이 없습니다.';
  }
  return result;
}
```
switch 구문 : brake 가 없으면 바로 다음 case로 넘어감.
switch-case-break

## 3. 반복문 (Looping Statement)
프로그래밍을 하다보면 유사한 작업을 여러 번 반복해서 해야할 경우가 있습니다.

- 스프레드시트의 A열에 있는 각 셀의 글자수를 구해서 B열에 집어넣는 작업을 첫 번째 행부터 1000 번째 행까지 반복
- 바둑의 승리자가 결정될 때까지 번갈아가며 턴을 반복
- 게시글에 달린 여러 개의 댓글을 보여주는 작업을 각 댓글에 대해 반복

위와 같은 작업을 하기 위해 JavaScript에서는 반복문(looping statement)을 사용합니다. 반복문은 루프라고 불리기도 합니다.
### 1. while
while 구문은 특정 조건을 만족하는 한 코드를 반복해서 실행시킵니다.
### 2. do...while 구문
do...while 구문은 while 구문과 사용법은 크게 다르지 않으나, 내부 코드를 무조건 한 번은 실행시킨다는 차이점이 있습니다.

### 3. for 구문
for 구문으로 정의된 루프는 항상 while 구문으로 바꿔쓸 수 있고, 많은 경우 반대로도 바꿀 수 있습니다. 다만 위와 같이 초기값을 정할 수 있고 갱신을 위한 코드가 짧은 경우에는 for 구문을, 그렇지 않은 경우에는 while 구문을 사용해야 코드가 깔끔해집니다.

* break, continue
### break
```js
alert('퀴즈를 시작합니다.');
while (true) {
  const answer = prompt('빨강의 보색은 무엇일까요?');
  if (answer === '초록') {
    alert('정답입니다! 🎉');
    break; // 루프를 종료하고 다음 코드로 넘어감
  } else {
    alert('틀렸습니다! 다시 시도해보세요.');
  }
}
alert('퀴즈가 끝났습니다.');
```
### continue
```js
for (let i = 1; i < 100; i++) {
  console.log(`현재 숫자는 ${i} 입니다.`);
  if (i % 7 !== 0) {
    continue; // 루프의 나머지 코드를 건너뜀
  }
  console.log(`${i}는 7의 배수입니다.`);
}
```
* 함수를 즉시 종료하기(return, throw)
### return
```js
function translateColor(english) {
  switch (english) {
    case 'red': return '빨강색';
    case 'blue': return '파랑색';
    case 'purple':
    case 'violet': return '보라색';
    default: return '일치하는 색깔이 없습니다.';
  }
}
```
### throw
```js
function translateColor(english) {
  switch (english) {
    case 'red': return '빨강색';
    case 'blue': return '파랑색';
    case 'purple':
    case 'violet': return '보라색';
    default: throw new Error('일치하는 색깔이 없습니다.');
  }
}
```
# 스코프 (Scope)
```js
function add(x, y) { // 변수 `x`와 `y`가 정의됨
  return x + y;
}
add(2, 3);
console.log(x); // 에러!
```
> ReferenceError: x is not defined
    at eval:6:13
    at eval
    at new Promise

위에 코드를 보면 x에서 referenceError가 발생한다. 이는 변수가 유효한 스코프를 넘었기 때문이다. 스코프는 특정 변수가 유효한 범위라고 한다. c언어 에서의 지역변수의 범위와 비슷하다.
위예제에서는 함수 스코프를 같는다.

## 스코프 연쇄 (Scope Chain)

함수 내부 코드에서, 매개변수 혹은 그 함수 안에서 정의된 변수만 사용할 수 있는 것은 아니다.
```js
const five = 5;
function add5(x) {
  return x + five; // 바깥 스코프의 `five` 변수에 접근
}
add5(3); // 8
```
위의 코드는 add5 함수의 return 구문에서 함수 바깥에 있는 변수 five의 값을 가져와 사용했다. 이는 심지어 함수가 여러 겹 중첩(nested)되어 있다고 하더라도 가능하다. `이렇게 여러 겹의 중첩이 된 스코프를 스코프 연쇄라고 한다.`
코드의 실행 흐름이 식별자에 도달하면, 먼저 그 식별자와 같은 이름을 갖는 변수를 현재 스코프에서 찾아보고, 변수가 존재하면 그것을 그대로 사용한다.
 만약 현재 스코프에서 변수를 찾지 못하면 바로 바깥쪽 스코프에서 변수를 찾아본다. 있으면 사용하고 없으면 바깥쪽 스코프로 올라가서 다시 찾아보는, 이 과정이 되풀이된다. 이런 과정을 스코프 연쇄(scope chain)라 하고, 이 과정은 가장 바깥쪽에 있는 스코프를 만날 때까지 반복된다. 가장 바깥쪽 스코프까지 찾아봤는데도 같은 이름의 변수를 찾지 못하면, 그제서야 에러가 발생한다.

 ## 변수 가리기 (Variable Shadowing)

단일 스코프에서는 같은 이름을 갖는 서로 다른 변수가 존재할 수 없다. 하지만 스코프 연쇄가 일어나면 이야기가 달라진다. 아래의 코드에서는 x라는 이름을 갖는 변수가 세 번 정의되었다.
```js
const x = 3;

function add5(x) { // `x`라는 변수가 다시 정의됨
  function add(x, y) { // `x`라는 변수가 다시 정의됨
    return x + y;
  }
  return add(x, 5);
}

add5(x);
```

위와 같이, 바깥쪽 스코프에 존재하는 변수와 같은 이름을 같는 변수를 안쪽 스코프에서 재정의할 수 있다. 그렇게 되면 안쪽 스코프에서는 바깥쪽 스코프에 있는 이름이 무시된다. 이런 현상을 변수 가리기(variable shadowing)라고 한다.




---
# 2. TIL
자바스크립트는 어렵다 하지만 다른 언어들 보다 쉽다. 하지만 또 그렇지만은 않은거 같다. 알고리즘은 굉장히 빠른 계산능력이 요구된다. 다른사람들은 잘 따라가는것 같은데 나만 못 따라 가는것 같아서 걱정이다. 잘 할 수 있을 까 ㅠㅠ 얼른 내것으로 만들어야 겠다. 어렵다. 

---
# 3. 참조 refer 

* http://resoneit.blogspot.kr/2013/06/git.html

* [자바스크립트의 함수는 일급 객체이다](https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4)