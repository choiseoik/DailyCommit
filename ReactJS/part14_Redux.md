# 14 Redux를 이용한 데이터 다루기

> 내 호기심이 떨어지기 전에 Redux를 다뤄보고 싶어서 건너뛰기 시전

## 살펴볼 주제

- React 단방향 데이터 흐름의 이해
- Flux 데이터 아키텍처의 이해
- Redux 데이터 라이브러리 다루기

### 들어가기에 앞서..

그동안 우리는 React를 이용해서 사용자 인터페이스를 생성했다. 이는 React를 사용하는 가장 흔한 사례다. 그렇지만 대부분의 UI는 데이터를 처리해야 한다. 데이터는 서버 또는 다른 브라우저 요소에서 가져온다. React에서 데이터를 다룰때는 다음과 같이 여러가지 방법을 고려해볼수 있다.

- MCV계열의 프레임워크와 통합 : 달일 페이지 애플리케이션 개발에 MVC계열의 라이브러리를 이미 사용중이거나 사용할 계획이 있다면 이상적인 방법이다. 예를 들면 Backbone과 Backbone 모델 클래스를 사용하고 있는 경우를 들 수 있다.
- 직접 개발한 데이터 메서드 또는 라이브러리 사용 : 작은 UI컴포넌트 개발에 적합한 방법이다. 예를 들어 계좌목록 표를 위해서 계좌 목록 데이터를 가져오는 경우를 들 수 있다.
- React 스택(React와 친구들) 사용하기 : 큰 마찰 없이 React코드와 통합 할 수 있어 가장 호환성이 뛰어나고, React의 철학을 잘 반영할 수 있는 방법이다.

이 장에서는 위에서 언급도니 3번째 방법 중 가장 인기가 좋은 Redux에 대해서 살펴본다. 우선 React 컴포넌트의 데이터 흐름에 대해 살펴보자

```md
## Note

Flux아키텍처와 페이스북에서 개발한 flux 라이브러리도 있다. flux라이브러리 대신 Redux를 소개하는 이유는 Redux가 더 많은 프로젝트에서 활발히 사용되고 있기 때문이다. flux 라이브러리는 Flux 아키텍처의 개념 증명에 좀 더 가까우며 Redux는 Flux아키텍처를 따라 구현되었다. Redux와 flux 라이브러리를 모두 Flux아키텍처의 구현체라고 볼 수 있다.(이책에서는 flux라이브러리가 아닌 Flux아키텍처에 대해서만 다룬다.)
```

## 14.1 React의 단방향 데이터 흐름 지원

React는 단방향 데이터 흐름에 따라 작동하도록 설계된 뷰 레이어다. 단방향 바인딩 이라고도 부르는 단방향 데이터 패턴은 관심사 간에 변경 가능한 참조(또는 양방향 바인딩)가 없는 경우다. 예를 들어 뷰와 모델이 양방향으로 참조되지 않는다. 양방향 흐름에 대해서는 다시 설명할 것이다.

계좌 모델과 계좌 뷰가 있다고 가정하면 데이터가 계좌 모델에서 계좌 뷰로만 흘러가고, 역방향으로는 전달되지 않는다. 즉, 모델의 변경이 뷰의 변경을 일으키는 것이다. 뷰가 모델을 직접 변경할 수 없다는 점이 단방향 데이터 흐름을 이해하기 위한 핵심적인 내용이다.

React의 단방향 데이터 흐름 하에서는 컴포넌트에 어떤 내용이 입력되더라도 render()메서드를 통해 항상 동일하고 예측 가능한 결과를 얻을 수 있다. React패턴은 Angular.js 또는 다른 몇몇 프레임 워크에 적용된 양방향 바인딩 패턴과는 극명히 대조된다.

예를 들어 양방향 데이터 흐름에서는 모델의 변경이 뷰의 변경을 일으키고, 사용자 입력 같은 뷰의 변경도 모델의 변경을 일으킨다. 따라서 양방향 데이터 흐름 하에서는 뷰의 상태에 대한 예측 가능성이 떨어지고, 이해와 디버깅, 유지보수에 좀더 어려움을 겪는다. 양방향 데이터 흐름의 핵심은 뷰가 모델을 직접 수정할 수 있다는 점이다. 단방향 데이터 흐름과 대조되는 부분이다.

흥미로운 점은 Angular.js를 사용하는 개발자들이 양방향 데이터 흐름 방법을 선호한다는 점이다. 양방향 데이터 흐름을 사용하면 작성해야할 코드가 줄어든다는 점은 논쟁의 여지가 없는 사실이다.

예를들어 입력영역이 있다고 가정해 보자. 템플릿에 변수를 정의하기만 하면 사용자가 내용을 입력할 때마다 모델에서 값이 갱신될 것이다. 만약 XHR GET 요청을 통해 모델에 변경이 발생한다면 이에 따라 웹 페이지가 갱신될 것이다. 따라서 두 방향에서 변경이 발생할 수 있다. 뷰에서 모델이 변경되거나, 모델에서 뷰를 변경하는 것이다. 프로토타입 단계에서는 훌륭한 방법이지만 선능, 디버깅, 개발 규모으 ㅣ확장 등을 고려해야 하는 복잡한 UI를 개발하기에는 부족하다. 이 설명은 논란을 부를지도 모르지만 더 설명을 읽어보자.

필자는 양방향 흐름을 기반으로 하는 MVC 또는 MVW 프레임워크를 이용해서 UI가 복잡한 애플리케이션을 개발했고 문제도 없었따. 간단히 말해, 문제가 발생하는 이유는 여러 개의 뷰가 여러 개의 모델을 조작하거나, 반대로 여러 개의 모델이 여러 개의 뷰를 조작하는 경우가 있기 때문이다. 한 두개의 모델이나 뷰가 분리되어 있는 경우라면 큰 문제가 없을 것이다. 그렇지마 규모가 더 큰 애플리케이션에서는 더 많은 모델과 뷰가 서로를 갱신한다. 갱신을 일으킨 모델과 뷰를 쉽게 찾을 수 없고 순서도 알기 어려우므로 어떤 모델 또는 뷰가 특정한 상태가 되는 이유를 알아내는 것이 점점 더 어려워진다. 버그를 찾는 것뿐만 아니라 추적하는 것이 큰 이슈가 된다. 이것이 많은 개발자가 MVC프레임 워크에 사용된 양방향 데이터 흐름을 선호하지 않는 이유다. 이 개발자들은 양방향 데이터 흐름을 디버깅과 확장을 어렵게 하는 안티패턴으로 여긴다.

반면에 단방향 데이터 흐름은 모델이 뷰를 갱신할 뿐이다. 또한, 단방향 데이터 흐름은 뷰가 변경할 수 없는 상태 함수이므로 동형/유니버셜 자바스크립트를 적용한 서버 측 렌더링도 가능하다.

일단은 단방향 데이터 흐름이 React가 인기를 끄는 주요 원인이라는 점은 기억해두자.

- 단일 데이터 소스를 채택하여 코드 가독성도 좋고 이해하기 쉽다.(상태/모델=>뷰)
- 디버깅에 유리하고 시간여행 디버깅도 가능하다. 예를 들어 예외나 버그가 발생했을 때 기록을 서버로 전송하는 것이 간단하다.
- 헤드리스 브라우저를 사용하지 않는 서버 측 렌더링: 동형 또는 유니버셜 자바스크립트라고도 불린다.

혹시나 궁금한 독자가 있을지 몰라 Angular에 대한 개인적인 경험을 소개하면 이렇다. Angular1은 부족한 부분이 있다고 생각하므로 크게 다루지 않았고 Angular 2를 살펴보았다. 그리고 필자가 잘못 생각했다는 것을 깨닫고 실수를 수정했다. 이제 Angular코드는 다루지 않기로 한다.

## 14.2 Flux 데이터 아키텍처의 이해

Flux는 데이터 흐름을 위한 아키텍처 패턴으로 페이스북이 React앱에 사용하기 위해 개발하였다. Flux의 요지는 단방향 데이터 흐름을 적용하고 MVC계열 패턴의 복잡도를 제거하는 것이다.

일반적인 MVC 계열의 패턴을 살펴보자 사용자 조작으로 컨트롤러에 이벤트가 발생하면 컨트롤러가 모델을 처리한다. 이어서 모델에 따라 앱이 뷰를 렌더링 하고 광기가 시작된다. 개별 뷰는 모델을 갱신한다. 자체적인 모델뿐만 아니라 다른 모델도 갱신한다. 모델은 다시 뷰를 갱신한다. 이런 아키텍처 안에서는 방향을 잃기 쉽다. 이해하기 어렵고 디버깅도 힘든 아키텍처이다.

이와 다르게 Flux는 단방향 데이터 흐름의 사용을 제안한다. Flux는 뷰에서 발생한 액션이 디스패처를 거쳐 데이터 스토어를 호출한다.(Flux는 MVC를 대체한다. 단순히 용어가 아니다.) 스토어는 데이터와 뷰의 표현을 책임진다. 뷰는 데이터를 변경하지 않고, 디스패처를 이용해서 액션을 전달한다.

단방향 데이터 흐름은 좀 더 나은 테스트와 디버깅을 가능하게 한다.

역사적으로 볼 때 Flux는 하나의 아키텍처였다. 페이스북 팀이 flux모듈을 배포해서 React와 함께 쓸 수 있는 Flux 아키텍처를 구현했을 뿐이다. flux 모듈 Flux 아키텍처의 개념증명으로, React개발자들이 많이 사용하지 않는다.

개인적으로 필자는 Flux가 혼란스러웠으며, 그것이 나만의 무넺가 아니라는 사실도 알게 되었다. Flux의 구현체로는 Redux, Reflux등 여러가지가 있다. 이 책의 초창기 온라인 버전에서는 Reflux를 다루었지만, 출간하면서 제외했다. 데이빗 윌러가 쓴 "React아키텍처 Flux vs Reflux"를 살펴보고, npm 다운로드 수치에서 Flux나 Reflux에 비해 Redux가 가장 인기 있는 라이브러리라는 사실을 알 수 있었다. 따라서 이 책에서는 Flux보다 더 나은 대안이라고도 이야기되는 Redux를 사용하고자 한다.

## 14.3 Redux 데이터 라이브러리 사용하기

Redux는 Flux아키텍처 구현체중 가장 인기가 높다. Redux의 특징은 다음과 같다.

- 훌륭한 개발 생태계 : Awesome Redux가 좋은 예다.
- 간결성 : 디스패처나 스토어 등록이 필요하지 않고, 최소화된 버전은 99행에 불과하다.
- 훌륭한 개발자 경험 : 핫 리로딩과 시간 여행 디버깅을 할수 있다. "실시간 React: 핫 리로딩 시간 여행"을 살펴보길 바란다.
- 리듀서 구성: 예를 들면 취소/다시하기 고차 컴포넌트를 사용하면 최소한의 코드만으로 기능을 구현할 수 있다.
- 서버측 렌더링 지원

Redux가 Flux에 비해 갖는 장점에 대해 세부사항 까지 살펴보지는 않을것이다. 세부적인 비교에 관심이 있다면 Redux 제작자가 소개한 "페이스북의 Flux대신 Redux를 선택해야 하는 이유"를 살펴고비 바란다.

Redux는 상태 컨테이너를 구현한 독립적인 라이브러리다. Redux는 런타임에서 애플리케이션이 처리하는 모든 데이터를 포함하고, 저장하고, 변경하는 커다란 변수다. Redux를 독립적으로 사용하거나 서버에서 사용할 수 있다. 앞서 언급한 것처럼 Redux를 React와 조합하여 사용하는 방법이 인기가 있다. 이 둘의 조합은 다른 라이브러리인 react-redux에 의해 구현된다.

React 앱에 Redux를 사용하면 다음과 같이 바뀌는 부분이 몇가지 있다.

- 스토어는 모든 데이터를 저장하고, 이 데이터를 조작할 수 있는 메서드를 제공한다. 스토어를 생성할 때는 createStore()메서드를 사용한다.
- Provider 컴포넌트는 모든 컴포넌트가 스토어에서 데이터를 가져올 수 있도록 만들어 준다.
- connet()메서드는 컴포넌트를 감싸서 스토어에 있는 애플리케이션 상태의 일부를 컴포넌트의 속성으로 연결한다.

이제 왜 스토어가 있는지 이해할 수 있을 것이다. 내부 상태를 변경하는 유일한 방법은 디스패처를 이용해 액션을 보내는 것이고, 액션은 스토어에 있다.

스토어의 모든 변경은 **액션**에 의해 이뤄진다. 각 액션은 애플리케이션에 발생한 일과 이에 따라 스토어에서 변경되어야 할 부분을 알려준다. 또한, 액션은 데이터를 제공하기도 한다. 모든 애플리케이션에는 변경되는 데이터가 있으므로 이런 방식이 유용함을 곧 깨닫게 될 것이다.

스토어에서 데이터의 변경 방법은 순수함수인 리듀서에 의해 명시된다. 리듀서는 (state, action)=>state 서명을 가지고 있다. 즉, 현재 상태에 액션을 적용하여 새로운 상태를 얻는 것이다. 이 덕분에 애플리케이션 상태를 예측할 수 있고, 취소 또는 디버깅을 통해 이전 상태로 되돌릴 수 있는 기능도 갖게 된다.

다음은 할일 목록 앱의 리듀서 파일이다. SET_VISIBILITY_FILTER와 ADD_TODO는 액션이다.

```js
function todoApp(state = initialState, action){
  switch(action.type){
    case 'SET_VISIBILITY_FILTER': // 액션을 정의한다
      return Object.assign({}, state, { // 리듀서가 현재 상태와 visibilityFilter 값을 복사하여 새로운 상태를 생성하도록 적용한다.
        visibilityFilter: action.filter
      })
    case 'ADD_TODO': // ADD_TODO 액션을 정의한다.
      return Object.assign({}, state, { // 리듀서가 현재 상태와 새로운 TOOD값인 'text'와 'completed'를 todos 배열의 마지막 항목으로 복사하여 새로운 상태를 생성하도록 적용한다.
        todos: [
          ...state.todos,
          {
            text: action.text,
            completed: false
          }
        ]
      })
      default:
      return state // 해당하는 액션이 없는 경우 기본적으로 현재 상태를 반환하도록 정의한다.
  }
}

```

Redux 애플리케이션은 하나 또는 그 이상의 리듀서를 둘 수 있다. 액션을 호출할 때마다 모든 리듀서가 호출된다. 리듀서는 스토어의 데이터 변경에 대한 책임이 있으므로 특정한 형식의 액션을 다룰 때는 주의해야한다.

일반적으로 리듀서는 상태와 액션을 인자로 받는 함수다. 예를 들어 영화정보를 가져오도록 하는 액션이 있다면 이때 리듀서를 사용한다. 액션 코드는 액션이 현재 상태를 다음 상태로 변환하는 과정(상태에 영화를 추가하는 과정)을 설명한다. 리듀서 함수는 액션을 처리하는 거대한 switch/case 문이다. 그렇지만 리듀서를 좀 더 함수형 프로그래밍적이고, 읽기 편하게 해주는 라이브러리도 있다. redux-actions라는 라이브러리를 이용해서 switch/case문을 대체하는 법을 살펴볼 것이다.

### 14.3.1 Redux를 이용한 넷플릭스 따라잡기

명작 영화 목록을 보여주는 넷플릭스 앱을 만들어보자. 앱은 영화를 격자로 보여주고, 영화 포스터를 클릭하면 영화에 대한 정보를 자세히 보여준다
이번 예제의 목표는 Redux를 사용해서 실시간으로 React 컴포넌트에 데이터를 공급하는 방법을 배우는 것이다. 단순한 예제이므로 데이터는 별도의 데이터서비스 없이 JSON파일에서 불러올 것이다. 또한, 이전 장에서 살펴본 React Route을 이용해서 각 영화의 상세 정보 화면으로 이동할 수 있게 할 것이다.

이 프로젝트에서는 3개의 컴포넌트, 즉 APP, Movies, Movie를 새엇ㅇ한다. 코드 정리를 위해 컴포넌트 별로 CSS파일이 있고 개별 폴더를 갖는다(React컴포넌트와 스타일을 캡슐화하는 모범사례이기도 하다.)

이제 프로젝트 폴더 구조의 준비를 마쳤다. 의존 모듈과 빌드 설정에 대해서 살펴보자.

### 14.3.2 의존 모듈과 빌드 설정

이 프로젝트에는 다수의 의존 모듈을 설치해야 한다. Webpack을 이용해서 모든 파일을 번들링하여 실시간으로 사용하고, extract-text-webpack-pulgin이라는 플러그인을 추가하여 여러개의 style 태그로 입력되었던 인라인CSS를 style.css파일로 만든다. 이 프로젝트에 사용할 Webpack 로더는 다음과 같다.

- json-loader
- style-loader
- css-loader
- babel-loader

그 외으 ㅣ프로젝트 개발 의존 모듈을 살펴보면 다음과 같다.

- Babel과 프리셋은 ES6코드를 브라우저에서 사용할 수 있는 ES5 자바스크립트 파일로 변환한다. babel-polyfill을 브라우저에 ES2015 환경을 갖추기 위해 사용하고, babel-preset-es2015는 ES6/ES2016, babel-preset-stage-0은 최신 ES7+ 기능을 제공하며, babel-preset-react는 JSX를 위해 사용한다.
- react-router는 현재 URL에 기반을 두어 컴포넌트의 계층을 보여준다. 또한, URL위치를 기반으로 컴포넌트 계층으로 배열하는 데 도움이 된다.
- redux-actions는 리듀서를 정리한다.
- ESLint와 플러그인은 자바스크립트와 JSX의 스타일을 적절하게 유지하기 위한 도구다
- concurrently는 Webpack 빌드와 같은 프로세스를 동시에 실행할 수 있게 해주는 Node.js도구다.

package.json파일은 모든 의존 모듈 목록과 Babel설정, npm 스크립트를 포함하며, 다음 예제 코드 14.1과 같다. npm i 모듈명으로 모듈을 직접 설치할 수도 있고, package.json을 생성하거나 복사해서 npm i ㅗㄹ 모듈을 설치할 수도 있다. package.json에 표시된 정확한 버전의 라이브러리를 사용하지 않으면 예제 코드가 정상적으로 작동하지 않을 수 있다.

의존 모듈을 번들링할 때 Webpack을 사용하므로 모든 필요한 패키지가 bundle.js에 포함된다. 따라서 모든 의존 모듈을 devDependencies에 추가한다.(배포환경에서 사용되지 않는 모듈이 불필요하게 배포되어 보안이 취약해지기 때문이다.) npm 은 npm i --production처럼 명령에 --production프래그가 설정되어 있을 때는 devDependencies를 무시한다.

다음으로 webpack.config.js를 생성해서 빌드과정을 정의해 보자.

### 14.3.3 Redux 사용하기

React 애플리케이션에서 Redux를 작동시키려면 컴포넌트 계층의 최상위에 Provider컴포넌트를 추가해야 한다. Provider 컴포넌트는 react-redux 패키지의 일부로 스토어의 데이터를 컴포넌트로 주입해준다. 즉, Provider 컴포넌트를 사용하면 모든 자식 컴포넌트가 스토어에 접근할수 있는 것이다. 깔금하다.

Provider 컴포넌트를 사용하려면 store속성으로 스토어를 전달해야 한다. 스토어는 애플리케이션 상태를 표현하는 객체다. Redux의 createStore()메서드는 index.js의 리듀서를 전달받아 스토어 객체를 반환한다.

Provider 컴포넌트와 하위 트리의 컴포넌트를 렌더링할 때는 react-dom의 render() 메서드를 사용한다. <Provider>를 첫번 째 인자로 받아 두번째 인자로 전달한 요소(document.getElementById('app'))안에 렌더링한다.

위에서 살펴본 내용을 종합하여 애플리케이션의 진입점 파일을 작성하면 다음 예제 코드와 같다. JSX포멧을 이용해서 Provider 컴포넌트를 정의하고 리듀서를 전달받은 스토어 인스턴스를 넘겨준다.

```js
const React = require("react");
const {render} = require("react-dom");
const { Provider} = require("react-redux");
const {createStore} = require("redux");
const reducers = require("./modules");
const routes = require("./routes.js");

module.exports = render(
  <Provider store={createStore(reducers)}>{routes}</Provider>
  document.getElementById("app")
);
```

전체 애플리케이션이 Redux의 기능을 사용하려면 스토어에 연결하는 코드처럼 자식 컴포넌트에서 구현해야 할 코드가 있다. react-redux의 connect()메서드는 몇가지 인자를 전달받아 함수를 반환한다. connect() 메서드가 반환한 함수로 컴포넌트를 감싸서 스토어의 일부를 컴포넌트의 속성으로 전달받게 된다.

여기까지 index.js작성을 마쳤다. Provider컴포넌트가 스토어로부터 연결된 컴포넌트로 데이터 전달을 처리하므로 속성을 직접 전달할 필요가 없다. 그렇지만 아직 라우팅, 리듀서, 액션 등에 대해서 살펴보지 않았다.

### 14.3.4 라우팅

react-router를 사용하면 브라우저의 경로에 따라 컴포넌트 계층을 정의할 수 있다. 13장에서 React Router를 살펴보았으므로 이미 익숙한 내용이라고 생각한다. 13장에서 React Router는 클라이언트 측의 라우팅을 위해 사용되었다. React 라우팅은 서버측 라우팅과 밀접하게 연결되어 있지는 않지만, 경우에 따라서 서버 측에서도 필요할 수 있는데, 이에 대해서는 16장에서 살펴보자

React Router의 핵심은 모든 경로를 여러 개의 중첩도니 Router 컴포넌트로 선언할 수 있다는 것이다. 각 Router 컴포넌트는 다음과 같이 두가지 속성을 전달받는다.

- path: URL 경로 또는 위치로 URL 매개변수를 포함할 수 있다. 예를 들면 loaclhost:8080/movies/1021은 movies:/id를 path로 사용할 수 있다. /를 사용하면 부모 Route 컴포넌트에 설정된 path와 상관없이 독립적인 경로를 사용할 수 있다. 이를테면 localhost:8080/1012 같은 경로에 대해 /:id를 path로 지정할 수 있다.

- component: 사용자가 해당 경로 또는 위치로 접근했을 때 렌더링할 컴포넌트에 대한 참조다. Provider 컴포넌트를 포함한 모든 부모 컴포넌트가 렌더링될 것이다. 예를 들어 예제 코드 14.4 에서 localhost:8080/movies/1021로 접근하면 Movie, Movies.App컴포넌트를 렌더링한다.

최상위 페이지와 /movies 페이지에서 모두 영화 포스터 목록을 보여주어야 한다. 또한, /movies/:id로 접근하면 영화에 대한 상세 정보를 보여주어야 한다. 다음 예제에서는 라우팅 설정에 IndexRoute를 사용한다.

```js
const React = require('react')
const{
  Router,
  Route,
  IndexRoute,
  broserHistory
} = require('react-router')
const App = require('components/app/app.js')
const Movies = require('components/movies/movies.js')
const Moive = require('components/movie/movie.js')

modul.exports = (
  <Router history={browserHistory}>
    <Route path="/" component={App}>
      <IndexRoute component={App} />
      <Route path="movies" component={Movies}>
        <Route path=":id" component={Movie} />
      </Route>
    </Route>
  </Router>
)
```

IndexRoute와 Route는 모두 최상위 Route 컴포넌트 안에 중첩되어 있다. 이렇게 하면 Movies 컴포넌트가 최상위 페이지와 /movies 페이지에서 모두 렌더링 된다. 개별 영화 뷰는 특정 영화 정보를 Redux스토어에서 가져오기 위해 영화 ID가 필요하므로 경로를 정의할 때 URL 매개변수를 사용해야 한다. 경로에 콜론을 이용하여 path=":id"로 작성한다. 작은 창에서 반응형 CSS가 적용되어 나타나는 개별 영화 뷰의 모습과 URL이다. URL의 movies/8에서 8이 영화 ID다. 다음으로 Redux리듀서를 이용해 데이터를 가져오는 방법을 살펴보자.